\documentclass[a4paper, 11pt]{book}
\usepackage{minted}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\usepackage[style=authoryear]{biblatex}
\addbibresource{hdr.bib}
\addbibresource{other.bib}

\DeclareSourcemap{
  \maps[datatype=bibtex, overwrite]{
    \map{
      \perdatasource{hdr.bib}
      \step[fieldset=keywords, fieldvalue={, }, appendstrict]
      \step[fieldset=keywords, fieldvalue=me, append]
    }
    \map{
      \perdatasource{other.bib}
      \step[fieldset=keywords, fieldvalue={, }, appendstrict]
      \step[fieldset=keywords, fieldvalue=they, append]
    }
  }
}

\newminted{elpi}{fontsize=\small,autogobble,escapeinside=~~,mathescape=true,frame=leftline,framerule=0pt,framesep=1em}
\newmintinline{elpi}{fontsize=\small,autogobble,escapeinside=~~,mathescape=true,frame=leftline,framerule=0pt,framesep=1em}

\title{title}
\begin{document}

\setcounter{tocdepth}{4}
\tableofcontents

\chapter{Introduction}

\section{Beyond the odd order theorem}
\section{The beginning: a snowy day}

\chapter{Elpi the language: \emph{du A a Z}}
\cite{duaz}

\section{Prolog}

\begin{elpicode}
pred age o:string, o:int.
pred older o:string, o:string.
\end{elpicode}
    

\section{$\lambda$Prolog}

\begin{elpicode}
kind term type.
type lam (term -> term) -> term.
type app term -> term -> term.

pred copy i:term, o:term.
copy (lam F) (lam G) :- pi x\ copy x x => copy (F x) (G x).
copy (app A B) (app C D) :- copy A C, copy B D.
\end{elpicode}

\section{Constraint Handling Rules}

\begin{figure}
\begin{elpicode}
kind nat type.
type zero nat.
type succ nat -> nat.

pred odd i:nat.
pred even i:nat.
even zero.
odd (succ X) :- even X.
even (succ X) :- odd X.
even X :- var X, new_constraint (even X) [X].
odd X :- var X, new_constraint (odd X) [X].

pred double i:nat, o:nat.
double zero zero.
double (succ X) (succ (succ Y)) :- double X Y.
double X Y :- var X, new_constraint (double X Y) [X].

constraint even odd double {
  rule (even X) (odd X) <=> fail.
  rule (double _ X) <=> (even X).
}
\end{elpicode}
\caption[even odd]{Even and odd}
\end{figure}

\section{Elpi = $\lambda$Prolog + CHR}

constraints can be suspended goals or just data attached to variables.

in the first case,from a proof theory POV CHR is meta, it seen the unfinished AND
branches of the proof search tree and can take decisions, like merging two. a rule can
be given the meaning of $bla$. 

rules can also be non-logical, eg manage a state that is not part of 
the proof, e.g. one could fails when a rule is used more than 2 times.
sure, constraints are backtracked, CHR cannot see OR branches.

 
Constraints and CHR serve many purposes:
\begin{itemize}
  \item justify/implement some non-logical operations
  \item implement a state and its management
  \item schedule constraints
\end{itemize}

In mainstream programming one has a state. In purely functional language
one has devices to hide state passing (monads). We prefer the former.

When one uses uvar of ML to model uvars of OL he needs a state, for example
to assign a PL type to them, and means to avoid multiple type declarations for the same
uvar, or read the type.


\subsection{Syntactic sugar}

\subsubsection{Namespaces}

accumulate and no confusion.

\begin{elpicode}
namespace n1 {
  pred p.
}
q :- n1.p
shorten n1.{ p }.
q :- p.
\end{elpicode}

note that a type/mode declaration declares the belonging to a namespace.

\begin{elpicode}
p.
namespace n2 {
  pred p.
  q :- p.
}
\end{elpicode}

\subsubsection{Spilling}

names are the most important form of documentation.
LP forces one to name intermediate results, as in the ANF
in FP.

\begin{elpicode}
rapp L1 L2 L :- L = {rev {append L1 L2}}.
rapp L1 L2 L :- append L1 L2 L3, rev L3 L4, L = L4.
\end{elpicode}

\section{Example: Hindley Milner type inference}

the algorithm is meta since it needs to access the context and
in particular see the unassigned variables.

\begin{figure}
\begin{elpicode}
% terms
kind term type.
type global  string -> term.
type app term -> term -> term.
type lam (term -> term) -> term.
type let term -> ty -> (term -> term) -> term.
type eq  term -> term -> term.

% type expressions
kind tye type.
type (==>) tye -> tye -> tye.  

% types
kind ty type.
type all    eq? -> (tye -> ty) -> ty.
type mono   tye -> ty.

% type quantification
kind eq? type.
type any eq?. % any type
type eqt eq?. % type with an equality test

% builtin types
type int   tye.
type bool  tye.
type list  tye -> tye.
type pair  tye -> tye -> tye.
\end{elpicode}
\caption[syntax]{Syntax of terms and types\label{hm:syntax}}
\end{figure}


\begin{figure}
\begin{elpicode}
pred of i:term, o:ty.
of (global "1")      (mono int).
of (global "2")      (mono int).
of (global "3")      (mono int).
of (global "plus")   (mono (int ==> int ==> int)).
of (global "[]")    (all any x\ mono (list x)).
of (global "::")    (all any x\ mono (x ==> list x ==> list x)).
of (global "size")  (all any x\ mono (list x ==> int)).
of (global "undup") (all eqt x\ mono (list x ==> list x)).
of (global ",")     (all any x\ all any y\ mono (x ==> y ==> (pair x y))).
\end{elpicode}
\caption[type assignments]{Type assignments\label{hm:env}}
\end{figure}
  
\begin{figure}
\begin{elpicode}
pred specialize i:ty, o:tye.
specialize (mono T) T.
specialize (all any F) T :- specialize (F Fresh_) T.
specialize (all eqt F) T :- specialize (F Fresh) T, eqbar Fresh.

pred eqbar i:tye.
eqbar bool.
eqbar int.
eqbar (list A) :- eqbar A.
eqbar (pair A B) :- eqbar A, eqbar B.

eqbar T :- var T, new_constraint (eqbar T) [T,_].
eqbar T :- print "KO: type" T "has no equality", halt.
\end{elpicode}
\caption[schema elimination]{Type schema elimination\label{hm:elim}}
\end{figure}

\begin{figure}
\begin{elpicode}
% theta carries the list of type variables for which eqbar
% has to hold
pred theta i:list tye.
theta L :- new_constraint (theta L) [_].

% gammabar is not a real constraint, but rather a query to the meta
% level to compute a polymorphic type out of a monomorphic one and
% its context
pred gammabar i:ty, o:ty.
gammabar (mono T) TS :- new_constraint (gammabar (mono T) TS) [_].

% constraint store %
constraint of gammabar eqbar theta {
  rule (theta L)                    % matched
        \  (G ?- gammabar T TS)     % matched and removed
        |  (generalize L G T POLYT) % guard + syntesis
      <=> (TS = POLYT).             % new goal

  rule (eqbar V) \ (theta L) | (not(mem L V)) <=> (theta [V | L]).
}

pred generalize i:list tye, i:list prop, i:ty, o:ty.
generalize Theta Gamma (mono T) PolyT :-
  free-ty (mono T) [] VT,
  free-gamma Gamma [] VGamma,
  filter VT (x\ not(mem VGamma x)) ToQuantify,
  bind ToQuantify Theta T PolyT.

pred bind i:list tye, i:list tye, i:tye, o:ty.
bind [] _ T (mono T1) :- copy T T1.
bind [X|XS] Theta T (all E x\ T1 x) :-
  if (mem Theta X) (E = eqt) (E = any),
  pi c\ copy X c => bind XS Theta T (T1 c).

pred free-ty i:ty, i:list tye, o:list tye.
free-ty (mono X) L L1 :- free X L L1.
free-ty (all _ F) L L1 :- pi x\ free-ty (F x) L L1.

pred free-gamma i:list prop, i:list tye, o:list tye.
free-gamma [] L L.
free-gamma [of _ T|X] L L2 :- free-ty T L L1, free-gamma X L1 L2.

pred free i:tye, i:list tye, o:list tye.
free int L L.
free bool L L.
free (list A) L L1 :- free A L L1.
free (pair A B) L L2 :- free A L L1, free B L1 L2.
free (A ==> B) L L2 :- free A L L1, free B L1 L2.
free (uvar _ _ as X) L L1 :- if (mem L X) (L1 = L) (L1 = [X|L]).
\end{elpicode}
\caption[schema introduction]{Type schema introduction\label{hm:intro}}
\end{figure}


\begin{figure}
\begin{elpicode}
of (app H A) (mono T) :-
  of H (mono (S ==> T)),
  of A (mono S).

of (lam F) (mono (S ==> T)) :-
  pi x\ of x (mono S) => of (F x) (mono T).

of (let E PT B) (mono TB) :-
  of E (mono T),
  gammabar (mono T) PT,
  pi x\ of x PT => of (B x) (mono TB).

of (eq LHS RHS) (mono bool) :-
  of LHS (mono T),
  of RHS (mono T),
  eqbar T.

of X (mono T) :- of X (all E Poly), specialize (all E Poly) T.
\end{elpicode}
\caption[bidirectional]{Bidirectional typing\label{hm:bidir}}
\end{figure}

\begin{figure}
\begin{elpicode}
of (app H A) (mono T) :-
  of H (mono TH),
  of A (mono TA),
  assert H TH (TA ==> T).

of (lam F) (mono (S ==> T)) :-
  pi x\ of x (mono S1) => of (F x) (mono T1),
  assert (lam F) (S1 ==> T1) (S ==> T).

of (let E PT B) (mono TB) :-
  of E (mono T),
  gammabar (mono T) PT,
  pi x\ of x PT => of (B x) (mono TB1),
  assert (B x) TB1 TB.

of (eq LHS RHS) (mono B) :-
  of LHS (mono TL),
  of RHS (mono TR),
  eqbar TL,
  assert RHS TR TL,
  assert (eq LHS RHS) bool B.

of X (mono T) :- of X (all E Poly), specialize (all E Poly) T1, assert X T1 T.

pred assert i:term, i:tye, i:tye.
assert _ TY ETY :- TY = ETY, !.
assert T TY ETY :-
  print "KO: term" T "has type" TY "but its context expects" ETY, halt.
\end{elpicode}
\caption[monodirectional]{Monodirectional typing\label{hm:mono}}
\end{figure}

\section{Pitfalls}

\begin{enumerate}
  \item \elpiinline{xx}
\end{enumerate}

\chapter{Elpi the software: from A to Z}

\section{The runtime}

\cite{dunchev15lpar}

\subsection{The $L_{\lambda}$ fragment}
\subsection{The $L_{\lambda}^{\beta}$ fragment}
\cite{Michaylov1993HigherOrderLP}

\subsection{Indexing}
\subsubsection{Patricial tree}
\subsubsection{Discrimination tree}
\subsubsection{Hash map}

\section{The API}

\subsection{Quotations}
\subsection{FFI}
\subsection{Code generation}

\chapter{Embedding in Coq: Coq-Elpi}

\section{HOAS of terms and contexts}

\section{HOAS of holes (missing terms)}



\chapter{Coq applications}

\section{Derive}
\subsection{Natural equality tests}
\subsection{Fast equality tests}
\subsection{Parametricity at work}

\section{Hierarchy Builder}
\subsection{Mathematical Components 2.0}

\section{Other applications / uses}
\subsection{Algebra Tactics}
\subsection{Tackt and TRocq: proof transfer tool}
\subsection{EIris: ???}
\subsection{BedRock's BRICK}
\subsubsection{N.E.S.}
\subsubsection{Derive plugins}


\chapter{Conclusions}
\section{Future work}
\nocite{*}
\printbibliography[title={Our Bibliography}, keyword=me]
\printbibliography[title={Bibliography}, keyword=they]
\end{document}