@inproceedings{Michaylov1993HigherOrderLP,
  title={Higher-Order Logic Programming as Constraint Logic Programming},
  author={Spiro Michaylov and Frank Pfenning},
  booktitle={Principles and Practice of Constraint Programming},
  year={1993},
  url={https://api.semanticscholar.org/CorpusID:9980455}
}
@book{Miller_Nadathur_2012, place={Cambridge}, title={Programming with Higher-Order Logic}, publisher={Cambridge University Press}, author={Miller, Dale and Nadathur, Gopalan}, year={2012}}
@book{ridoux1998lambda,
  title={Lambda-Prolog de A {\`a} Z... ou presque},
  author={Ridoux, O.},
  url={https://books.google.fr/books?id=XFhGXwAACAAJ},
  year={1998}
}
@InProceedings{sakaguchi:LIPIcs.ITP.2022.29,
  author =	{Sakaguchi, Kazuhiko},
  title =	{{Reflexive Tactics for Algebra, Revisited}},
  booktitle =	{13th International Conference on Interactive Theorem Proving (ITP 2022)},
  pages =	{29:1--29:22},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-252-5},
  ISSN =	{1868-8969},
  year =	{2022},
  volume =	{237},
  editor =	{Andronick, June and de Moura, Leonardo},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2022.29},
  URN =		{urn:nbn:de:0030-drops-167385},
  doi =		{10.4230/LIPIcs.ITP.2022.29},
  annote =	{Keywords: Coq, Elpi, \lambdaProlog, Mathematical Components, algebraic structures, packed classes, canonical structures, proof by reflection}
}
@InProceedings{10.1007/978-3-031-57262-3_10,
author="Cohen, Cyril
and Crance, Enzo
and Mahboubi, Assia",
editor="Weirich, Stephanie",
title="Trocq: Proof Transfer for Free, With or Without Univalence",
booktitle="Programming Languages and Systems",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="239--268",
abstract="This article presents Trocq, a new proof transfer framework for dependent type theory. Trocq is based on a novel formulation of type equivalence, used to generalize the univalent parametricity translation. This framework takes care of avoiding dependency on the axiom of univalence when possible, and may be used with more relations than just equivalences. We have implemented a corresponding plugin for the Coq interactive theorem prover, in the Coq-Elpi meta-language.",
isbn="978-3-031-57262-3"
}


@book{Jojgov,
title = "Systems for open terms : an overview",
author = "G.I. Jojgov",
year = "2001",
language = "English",
series = "Computer science reports",
publisher = "Technische Universiteit Eindhoven",

}

@article{miller92jsc,
  author =       "Dale Miller",
  title =        "Unification under a mixed prefix",
  year =         "1992",
  journal =      "Journal of Symbolic Computation",
  pages =        "321--358",
  volume =       "14",
  number =       "4",
  doi =          "10.1016/0747-7171(92)90011-R",
  pdf =          "http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/jsc92.pdf",
}

@misc{Coq-refman,
  title = "The {Rooq} Reference Manual -- Release 9.0.0",
  author = "{The Rocq Development Team}",
  year = "2025",
  howpublished = "\url{https://rocq-prover.org/doc/V9.0.0/refman/index.html}"
}
@inproceedings{dealmeidaborges_et_al:LIPIcs.ITP.2023.12,
  author =	{de Almeida Borges, Ana and Casanueva Art{\'\i}s, Annal{\'\i} and Falleri, Jean-R\'{e}my and Gallego Arias, Emilio Jes\'{u}s and Martin-Dorel, \'{E}rik and Palmskog, Karl and Serebrenik, Alexander and Zimmermann, Th\'{e}o},
  title =	{{Lessons for Interactive Theorem Proving Researchers from a Survey of Coq Users}},
  booktitle =	{14th International Conference on Interactive Theorem Proving (ITP 2023)},
  pages =	{12:1--12:18},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-284-6},
  ISSN =	{1868-8969},
  year =	{2023},
  volume =	{268},
  editor =	{Naumowicz, Adam and Thiemann, Ren\'{e}},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2023.12},
  URN =		{urn:nbn:de:0030-drops-183875},
  doi =		{10.4230/LIPIcs.ITP.2023.12},
  annote =	{Keywords: Coq, Community, Survey, Statistical Analysis}
}
@inproceedings{DBLP:conf/cpp/Blot0CPKMV23,
  author       = {Valentin Blot and
                  Denis Cousineau and
                  Enzo Crance and
                  Louise Dubois de Prisque and
                  Chantal Keller and
                  Assia Mahboubi and
                  Pierre Vial},
  editor       = {Robbert Krebbers and
                  Dmitriy Traytel and
                  Brigitte Pientka and
                  Steve Zdancewic},
  title        = {Compositional Pre-processing for Automated Reasoning in Dependent
                  Type Theory},
  booktitle    = {Proceedings of the 12th {ACM} {SIGPLAN} International Conference on
                  Certified Programs and Proofs, {CPP} 2023, Boston, MA, USA, January
                  16-17, 2023},
  pages        = {63--77},
  publisher    = {{ACM}},
  year         = {2023},
  url          = {https://doi.org/10.1145/3573105.3575676},
  doi          = {10.1145/3573105.3575676},
  timestamp    = {Tue, 07 Mar 2023 15:01:48 +0100},
  biburl       = {https://dblp.org/rec/conf/cpp/Blot0CPKMV23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@book{10.5555/1200583,
author = {Ierusalimschy, Roberto},
title = {Programming in Lua, Second Edition},
year = {2006},
isbn = {8590379825},
publisher = {Lua.Org}
}

@InProceedings{10.1007/978-3-540-27775-0_7,
author="Duck, Gregory J.
and Stuckey, Peter J.
and de la Banda, Mar{\'i}a Garc{\'i}a
and Holzbaur, Christian",
editor="Demoen, Bart
and Lifschitz, Vladimir",
title="The Refined Operational Semantics of Constraint Handling Rules",
booktitle="Logic Programming",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="90--104",
abstract="Constraint Handling Rules (CHRs) are a high-level rule-based programming language commonly used to write constraint solvers. The theoretical operational semantics for CHRs is highly non-deterministic and relies on writing confluent programs to have a meaningful behaviour. Implementations of CHRs use an operational semantics which is considerably finer than the theoretical operational semantics, but is still non-deterministic (from the user's perspective). This paper formally defines this refined operational semantics and proves it implements the theoretical operational semantics. It also shows how to create a (partial) confluence checker capable of detecting programs which are confluent under this semantics, but not under the theoretical operational semantics. This supports the use of new idioms in CHR programs.",
isbn="978-3-540-27775-0"
}
@article{chr, title={As time goes by: Constraint Handling Rules: A survey of CHR research from 1998 to 2007}, volume={10}, DOI={10.1017/S1471068409990123}, number={1}, journal={Theory and Practice of Logic Programming}, author={SNEYERS, JON and VAN WEERT, PETER and SCHRIJVERS, TOM and DE KONINCK, LESLIE}, year={2010}, pages={1–47}}


@InProceedings{keller_et_al:LIPIcs.CSL.2012.381,
  author =	{Keller, Chantal and Lasson, Marc},
  title =	{{Parametricity in an Impredicative Sort}},
  booktitle =	{Computer Science Logic (CSL'12) - 26th International Workshop/21st Annual Conference of the EACSL},
  pages =	{381--395},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-939897-42-2},
  ISSN =	{1868-8969},
  year =	{2012},
  volume =	{16},
  editor =	{C\'{e}gielski, Patrick and Durand, Arnaud},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2012.381},
  URN =		{urn:nbn:de:0030-drops-36851},
  doi =		{10.4230/LIPIcs.CSL.2012.381},
  annote =	{Keywords: Calculus of Inductive Constructions, parametricity, impredicativity, Coq, universes}
}

@misc{selsam2020tabledtypeclassresolution,
      title={Tabled Typeclass Resolution}, 
      author={Daniel Selsam and Sebastian Ullrich and Leonardo de Moura},
      year={2020},
      eprint={2001.04301},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2001.04301}, 
}
@article{MILNER1978348,
title = {A theory of type polymorphism in programming},
journal = {Journal of Computer and System Sciences},
volume = {17},
number = {3},
pages = {348-375},
year = {1978},
issn = {0022-0000},
doi = {https://doi.org/10.1016/0022-0000(78)90014-4},
url = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
author = {Robin Milner},
abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.}
}

@article{NADATHUR200235,
title = {The Suspension Notation for Lambda Terms and its Use in Metalanguage Implementations},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {67},
pages = {35-48},
year = {2002},
note = {WoLLIC'2002, 9th Workhop on Logic, Language, Information and Computation},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80539-5},
url = {https://www.sciencedirect.com/science/article/pii/S1571066104805395},
author = {Gopalan Nadathur},
keywords = {logical framework, explicit substitution, suspension notation},
abstract = {Many metalanguages and logical frameworks have emerged in recent years that use the terms of the lambda calculus as data structures. A common set of questions govern the suitability of a representation for lambda terms in the implementation of such systems: α-convertibility must be easily recognizable, sharing in reduction steps, term traversal and term structure must be possible, comparison and unification operations should be efficiently supported and it should be possible to examine terms embedded inside abstractions. Explicit substitution notations for lambda calculi provide a basis for realizing such requirements. We discuss here the issues related to using one such notation—the suspension notation of Nadathur and Wilson—in this capacity. This notation has been used in two significant practical systems: the Standard ML of New Jersey compiler and the Teyjus implementation of λ-Prolog. We expose the theoretical properties of this notation, highlight pragmatic considerations in its use in implementing operations such as reduction and unification and discuss its relationship to other explicit substitution notations.}
}

@article{10.1145/3236788,
author = {Stampoulis, Antonis and Chlipala, Adam},
title = {Prototyping a functional language using higher-order logic programming: a functional pearl on learning the ways of $\lambda$Prolog/Makam},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236788},
doi = {10.1145/3236788},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {93},
numpages = {30},
keywords = {programming language prototyping, metaprogramming, higher-order logic programming}
}

@article{10.1145/3429979,
author = {Tabareau, Nicolas and Tanter, \'{E}ric and Sozeau, Matthieu},
title = {The Marriage of Univalence and Parametricity},
year = {2021},
issue_date = {February 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {68},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/3429979},
doi = {10.1145/3429979},
abstract = {Reasoning modulo equivalences is natural for everyone, including mathematicians. Unfortunately, in proof assistants based on type theory, which are frequently used to mechanize mathematical results and carry out program verification efforts, equality is appallingly syntactic, and as a result, exploiting equivalences is cumbersome at best. Parametricity and univalence are two major concepts that have been explored in the literature to transport programs and proofs across type equivalences, but they fall short of achieving seamless, automatic transport. This work first clarifies the limitations of these two concepts when considered in isolation and then devises a fruitful marriage between both. The resulting concept, called univalent parametricity, is an extension of parametricity strengthened with univalence that fully realizes programming and proving modulo equivalences. Our approach handles both type and term dependency, as well as type-level computation. In addition to the theory of univalent parametricity, we present a lightweight framework implemented in the Coq proof assistant that allows the user to transparently transfer definitions and theorems for a type to an equivalent one, as if they were equal. For instance, this makes it possible to conveniently switch between an easy-to-reason-about representation and a computationally efficient representation as soon as they are proven equivalent. The combination of parametricity and univalence supports transport \`{a} la carte: basic univalent transport, which stems from a type equivalence, can be complemented with additional proofs of equivalences between functions over these types, in order to be able to transport more programs and proofs, as well as to yield more efficient terms. We illustrate the use of univalent parametricity on several examples, including a recent integration of native integers in Coq. This work paves the way to easier-to-use proof assistants by supporting seamless programming and proving modulo equivalences.},
journal = {J. ACM},
month = jan,
articleno = {5},
numpages = {44},
keywords = {Coq, Type equivalence, parametricity, proof assistants, univalence}
}

@phdthesis{enzo,
  title        = {Meta-Programming for Proof Transfer in Dependent Type Theory},
  author       = {Enzo Crance},
  year         = 2023,
  month        = {December},
  address      = {Nantes},
  note         = {Available at \url{https://ecrance.net/files/thesis-Enzo-Crance-en-light.pdf}},
  school       = {University of Nantes},
  type         = {PhD thesis}
}

@phdthesis{mcbride,
  author       = {Conor McBride},
  title        = {Dependently typed functional programs and their proofs},
  school       = {University of Edinburgh, {UK}},
  year         = {2000},
  url          = {https://hdl.handle.net/1842/374},
  timestamp    = {Wed, 04 May 2022 12:59:24 +0200},
  biburl       = {https://dblp.org/rec/phd/ethos/McBride00.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@article{Miller2018MechanizedMR,
  title={Mechanized Metatheory Revisited},
  author={Dale A. Miller},
  journal={Journal of Automated Reasoning},
  year={2018},
  volume={63},
  pages={625 - 665},
  url={https://api.semanticscholar.org/CorpusID:8571809}
}

@inproceedings{mlts,
author = {G\'{e}rard, Ulysse and Miller, Dale and Scherer, Gabriel},
title = {Functional programming with λ-tree syntax},
year = {2019},
isbn = {9781450372497},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3354166.3354177},
doi = {10.1145/3354166.3354177},
abstract = {We present the design of a new functional programming language, MLTS, that uses the λ-tree syntax approach to encoding bindings appearing within data structures. In this approach, bindings never become free nor escape their scope: instead, binders in data structures are permitted to move to binders within programs. The design of MLTS includes additional sites within programs that directly support this movement of bindings. In order to formally define the language's operational semantics, we present an abstract syntax for MLTS and a natural semantics for its evaluation. We shall view such natural semantics as a logical theory within a rich logic that includes both nominal abstraction and the ∇-quantifier: as a result, the natural semantics specification of MLTS can be given a succinct and elegant presentation. We present a typing discipline that naturally extends the typing of core ML programs and we illustrate the features of MLTS by presenting several examples. An on-line interpreter for MLTS is briefly described.},
booktitle = {Proceedings of the 21st International Symposium on Principles and Practice of Declarative Programming},
articleno = {12},
numpages = {16},
location = {Porto, Portugal},
series = {PPDP '19}
}

@INPROCEEDINGS{abella,
  author = {Andrew Gacek},
  title = {The {A}bella Interactive Theorem Prover (System
                  Description)},
  year = 2008,
  month = {August},
  booktitle = {Proceedings of IJCAR 2008},
  pages = {154--161},
  publisher = {Springer},
  series = {Lecture Notes in Artificial Intelligence},
  volume = 5195,
  editor = {A. Armando and P. Baumgartner and G. Dowek},
  pdf = {http://arxiv.org/pdf/0803.2305.pdf},
  slides = {http://abella-prover.org/slides/gacek08ijcar-slides.pdf}
}
@inproceedings{logicT,
author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
title = {Backtracking, interleaving, and terminating monad transformers: (functional pearl)},
year = {2005},
isbn = {1595930647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1086365.1086390},
doi = {10.1145/1086365.1086390},
abstract = {We design and implement a library for adding backtracking computations to any Haskell monad. Inspired by logic programming, our library provides, in addition to the operations required by the MonadPlus interface, constructs for fair disjunctions, fair conjunctions, conditionals, pruning, and an expressive top-level interface. Implementing these additional constructs is easy in models of backtracking based on streams, but not known to be possible in continuation-based models. We show that all these additional constructs can be generically and monadically realized using a single primitive msplit. We present two implementations of the library: one using success and failure continuations; and the other using control operators for manipulating delimited continuations.},
booktitle = {Proceedings of the Tenth ACM SIGPLAN International Conference on Functional Programming},
pages = {192–203},
numpages = {12},
keywords = {streams, logic programming, control delimiters, continuations, Prolog, Haskell},
location = {Tallinn, Estonia},
series = {ICFP '05}
}
@InProceedings{fctc,
author="Sozeau, Matthieu
and Oury, Nicolas",
editor="Mohamed, Otmane Ait
and Mu{\~{n}}oz, C{\'e}sar
and Tahar, Sofi{\`e}ne",
title="First-Class Type Classes",
booktitle="Theorem Proving in Higher Order Logics",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="278--293",
abstract="Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.",
isbn="978-3-540-71067-7"
}
@InProceedings{brigittePHD,
author="Pientka, Brigitte",
editor="Nieuwenhuis, Robert",
title="Tabling for Higher-Order Logic Programming",
booktitle="Automated Deduction -- CADE-20",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="54--68",
abstract="We describe the design and implementation of a higher-order tabled logic programming interpreter where some redundant and infinite computation is eliminated by memoizing sub-computation and re-using its result later. In particular, we focus on the table design and table access in the higher-order setting where many common operations are undecidable in general. To achieve a space and time efficient implementation, we rely on substitution factoring and higher-order substitution tree indexing. Experimental results from a wide range of examples (propositional theorem proving, refinement type checking, small-step evaluator) demonstrate that higher-order tabled logic programming yields a more robust and more powerful proof procedure.",
isbn="978-3-540-31864-4"
}
@article{expsubst, title={Explicit substitutions}, volume={1}, DOI={10.1017/S0956796800000186}, number={4}, journal={Journal of Functional Programming}, author={Abadi, M. and Cardelli, L. and Curien, P.-L. and Lévy, J.-J.}, year={1991}, pages={375–416}}

@incollection{DEBRUIJN1994375,
title = {Lambda Calculus Notation with Nameless Dummies, a Tool for Automatic Formula Manipulation, with Application to the Church-Rosser Theorem**Reprinted from: Indagationes Math, 34, 5, p. 381-392, by courtesy of the Koninklijke Nederlandse Akademie van Wetenschappen, Amsterdam.},
editor = {R.P. Nederpelt and J.H. Geuvers and R.C. {de Vrijer}},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {133},
pages = {375-388},
year = {1994},
booktitle = {Selected Papers on Automath},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(08)70216-7},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X08702167},
author = {N.G. de Bruijn},
abstract = {In ordinary lambda calculus the occurrences of a bound variable are made recognizable by the use of one and the same (otherwise irrelevant) name at all occurrences. This convention is known to cause considerable trouble in cases of substitution. In the present paper a different notational system is developed, where occurrences of variables are indicated by integers giving the “distance” to the binding λ instead of a name attached to that λ. The system is claimed to be efficient for automatic formula manipulation as well as for metalingual discussion. As an example the most essential part of a proof of the Church-Rosser theorem is presented in this namefree calculus.}
}

@book{wam,
    author = {Aït-Kaci, Hassan},
    title = {Warren's Abstract Machine: A Tutorial Reconstruction},
    publisher = {The MIT Press},
    year = {1991},
    month = {08},
    abstract = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.Contents Introduction • Unification—Pure and Simple • Flat Resolution • Prolog • Optimizing the Design • Conclusion • Appendixes},
    isbn = {9780262255585},
    doi = {10.7551/mitpress/7160.001.0001},
    url = {https://doi.org/10.7551/mitpress/7160.001.0001},
}

@inproceedings{teyjus,
author = {Nadathur, Gopalan and Mitchell, Dustin J.},
title = {System Description: Teyjus - A Compiler and Abstract Machine Based Implementation of lambda-Prolog},
year = {1999},
isbn = {3540662227},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {The logic programming language λProlog is based on the intuitionistic theory of higher-order hereditary Harrop formulas, a logic that significantly extends the theory of Horn clauses. A systematic exploitation of features in the richer logic endows λProlog with capabilities at the programming level that are not present in traditional logic programming languages. Several studies have established the value of λProlog as a language for implementing systems that manipulate formal objects such as formulas, programs, proofs and types. Towards harnessing these benefits, methods have been developed for realizing this language efficiently. This work has culminated in the description of an abstract machine and compiler based implementation scheme. An actual implementation of λProlog based on these ideas has recently been completed. The planned presentation will exhibit this system--called Teyjus--and will also illuminate the metalanguage capabilities of λProlog.},
booktitle = {Proceedings of the 16th International Conference on Automated Deduction: Automated Deduction},
pages = {287–291},
numpages = {5},
series = {CADE-16}
}

@article{DBLP:journals/corr/abs-0911-5203,
  author       = {Xiaochu Qi},
  title        = {An Implementation of the Language Lambda Prolog Organized around Higher-Order
                  Pattern Unification},
  journal      = {CoRR},
  volume       = {abs/0911.5203},
  year         = {2009},
  url          = {http://arxiv.org/abs/0911.5203},
  eprinttype    = {arXiv},
  eprint       = {0911.5203},
  timestamp    = {Mon, 13 Aug 2018 16:48:41 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-0911-5203.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@InProceedings{10.1007/978-3-540-45085-6_40,
author="Pientka, Brigitte and Pfenning, Frank",
editor="Baader, Franz",
title="Optimizing Higher-Order Pattern Unification",
booktitle="Automated Deduction -- CADE-19",
year="2003",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="473--487",
abstract="We present an abstract view of existential variables in a dependently typed lambda-calculus based on modal type theory. This allows us to justify optimizations to pattern unification such as linearization, which eliminates many unnecessary occurs-checks. The presented modal framework explains a number of features of the current implementation of higher-order unification in Twelf and provides insight into several optimizations. Experimental results demonstrate significant performance improvement in many example applications of Twelf, including those in the area of proof-carrying code.",
isbn="978-3-540-45085-6"
}

@article{10.1093/logcom/1.4.497,
    author = {MILLER, DALE},
    title = {A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification},
    journal = {Journal of Logic and Computation},
    volume = {1},
    number = {4},
    pages = {497-536},
    year = {1991},
    month = {09},
    abstract = {It has been argued elsewhere that a logic programming language with function variables and λ-abstractions within terms makes a good meta-programming language, especially when an object-language contains notions of bound variables and scope. The λProlog logic programming language and the related Elf and Isabelle systems provide meta-programs with both function variables and λ-abstractions by containing implementations of higher order unification. This paper presents a logic programming language, called Lλ, that also contains both function variables and λ-abstractions, although certain restrictions are placed on occurrences of function variables. As a result of these restrictions, an implementation of Lλdoes not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using Lλ as a meta-programming language are presented.},
    issn = {0955-792X},
    doi = {10.1093/logcom/1.4.497},
    url = {https://doi.org/10.1093/logcom/1.4.497},
    eprint = {https://academic.oup.com/logcom/article-pdf/1/4/497/3817142/1-4-497.pdf},
}


