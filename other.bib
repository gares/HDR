@inproceedings{Michaylov1993HigherOrderLP,
  title={Higher-Order Logic Programming as Constraint Logic Programming},
  author={Spiro Michaylov and Frank Pfenning},
  booktitle={Principles and Practice of Constraint Programming},
  year={1993},
  url={https://api.semanticscholar.org/CorpusID:9980455}
}
@book{Miller_Nadathur_2012, place={Cambridge}, title={Programming with Higher-Order Logic}, publisher={Cambridge University Press}, author={Miller, Dale and Nadathur, Gopalan}, year={2012}}
@book{ridoux1998lambda,
  title={Lambda-Prolog de A {\`a} Z... ou presque},
  author={Ridoux, O.},
  url={https://books.google.fr/books?id=XFhGXwAACAAJ},
  year={1998}
}
@InProceedings{sakaguchi:LIPIcs.ITP.2022.29,
  author =	{Sakaguchi, Kazuhiko},
  title =	{{Reflexive Tactics for Algebra, Revisited}},
  booktitle =	{13th International Conference on Interactive Theorem Proving (ITP 2022)},
  pages =	{29:1--29:22},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-252-5},
  ISSN =	{1868-8969},
  year =	{2022},
  volume =	{237},
  editor =	{Andronick, June and de Moura, Leonardo},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2022.29},
  URN =		{urn:nbn:de:0030-drops-167385},
  doi =		{10.4230/LIPIcs.ITP.2022.29},
  annote =	{Keywords: Coq, Elpi, \lambdaProlog, Mathematical Components, algebraic structures, packed classes, canonical structures, proof by reflection}
}
@InProceedings{10.1007/978-3-031-57262-3_10,
author="Cohen, Cyril
and Crance, Enzo
and Mahboubi, Assia",
editor="Weirich, Stephanie",
title="Trocq: Proof Transfer for Free, With or Without Univalence",
booktitle="Programming Languages and Systems",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="239--268",
abstract="This article presents Trocq, a new proof transfer framework for dependent type theory. Trocq is based on a novel formulation of type equivalence, used to generalize the univalent parametricity translation. This framework takes care of avoiding dependency on the axiom of univalence when possible, and may be used with more relations than just equivalences. We have implemented a corresponding plugin for the Coq interactive theorem prover, in the Coq-Elpi meta-language.",
isbn="978-3-031-57262-3"
}


@book{Jojgov,
title = "Systems for open terms : an overview",
author = "G.I. Jojgov",
year = "2001",
language = "English",
series = "Computer science reports",
publisher = "Technische Universiteit Eindhoven",

}

@article{miller92jsc,
  author =       "Dale Miller",
  title =        "Unification under a mixed prefix",
  year =         "1992",
  journal =      "Journal of Symbolic Computation",
  pages =        "321--358",
  volume =       "14",
  number =       "4",
  doi =          "10.1016/0747-7171(92)90011-R",
  pdf =          "http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/jsc92.pdf",
}

@misc{Coq-refman,
  title = "The {Rooq} Reference Manual -- Release 9.0.0",
  author = "{The Rocq Development Team}",
  year = "2025",
  howpublished = "\url{https://rocq-prover.org/doc/V9.0.0/refman/index.html}"
}
@inproceedings{dealmeidaborges_et_al:LIPIcs.ITP.2023.12,
  author =	{de Almeida Borges, Ana and Casanueva Art{\'\i}s, Annal{\'\i} and Falleri, Jean-R\'{e}my and Gallego Arias, Emilio Jes\'{u}s and Martin-Dorel, \'{E}rik and Palmskog, Karl and Serebrenik, Alexander and Zimmermann, Th\'{e}o},
  title =	{{Lessons for Interactive Theorem Proving Researchers from a Survey of Coq Users}},
  booktitle =	{14th International Conference on Interactive Theorem Proving (ITP 2023)},
  pages =	{12:1--12:18},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-284-6},
  ISSN =	{1868-8969},
  year =	{2023},
  volume =	{268},
  editor =	{Naumowicz, Adam and Thiemann, Ren\'{e}},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2023.12},
  URN =		{urn:nbn:de:0030-drops-183875},
  doi =		{10.4230/LIPIcs.ITP.2023.12},
  annote =	{Keywords: Coq, Community, Survey, Statistical Analysis}
}
@inproceedings{DBLP:conf/cpp/Blot0CPKMV23,
  author       = {Valentin Blot and
                  Denis Cousineau and
                  Enzo Crance and
                  Louise Dubois de Prisque and
                  Chantal Keller and
                  Assia Mahboubi and
                  Pierre Vial},
  editor       = {Robbert Krebbers and
                  Dmitriy Traytel and
                  Brigitte Pientka and
                  Steve Zdancewic},
  title        = {Compositional Pre-processing for Automated Reasoning in Dependent
                  Type Theory},
  booktitle    = {Proceedings of the 12th {ACM} {SIGPLAN} International Conference on
                  Certified Programs and Proofs, {CPP} 2023, Boston, MA, USA, January
                  16-17, 2023},
  pages        = {63--77},
  publisher    = {{ACM}},
  year         = {2023},
  url          = {https://doi.org/10.1145/3573105.3575676},
  doi          = {10.1145/3573105.3575676},
  timestamp    = {Tue, 07 Mar 2023 15:01:48 +0100},
  biburl       = {https://dblp.org/rec/conf/cpp/Blot0CPKMV23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@book{10.5555/1200583,
author = {Ierusalimschy, Roberto},
title = {Programming in Lua, Second Edition},
year = {2006},
isbn = {8590379825},
publisher = {Lua.Org}
}

@InProceedings{10.1007/978-3-540-27775-0_7,
author="Duck, Gregory J.
and Stuckey, Peter J.
and de la Banda, Mar{\'i}a Garc{\'i}a
and Holzbaur, Christian",
editor="Demoen, Bart
and Lifschitz, Vladimir",
title="The Refined Operational Semantics of Constraint Handling Rules",
booktitle="Logic Programming",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="90--104",
abstract="Constraint Handling Rules (CHRs) are a high-level rule-based programming language commonly used to write constraint solvers. The theoretical operational semantics for CHRs is highly non-deterministic and relies on writing confluent programs to have a meaningful behaviour. Implementations of CHRs use an operational semantics which is considerably finer than the theoretical operational semantics, but is still non-deterministic (from the user's perspective). This paper formally defines this refined operational semantics and proves it implements the theoretical operational semantics. It also shows how to create a (partial) confluence checker capable of detecting programs which are confluent under this semantics, but not under the theoretical operational semantics. This supports the use of new idioms in CHR programs.",
isbn="978-3-540-27775-0"
}
@article{chr, title={As time goes by: Constraint Handling Rules: A survey of CHR research from 1998 to 2007}, volume={10}, DOI={10.1017/S1471068409990123}, number={1}, journal={Theory and Practice of Logic Programming}, author={SNEYERS, JON and VAN WEERT, PETER and SCHRIJVERS, TOM and DE KONINCK, LESLIE}, year={2010}, pages={1–47}}


@InProceedings{keller_et_al:LIPIcs.CSL.2012.381,
  author =	{Keller, Chantal and Lasson, Marc},
  title =	{{Parametricity in an Impredicative Sort}},
  booktitle =	{Computer Science Logic (CSL'12) - 26th International Workshop/21st Annual Conference of the EACSL},
  pages =	{381--395},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-939897-42-2},
  ISSN =	{1868-8969},
  year =	{2012},
  volume =	{16},
  editor =	{C\'{e}gielski, Patrick and Durand, Arnaud},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2012.381},
  URN =		{urn:nbn:de:0030-drops-36851},
  doi =		{10.4230/LIPIcs.CSL.2012.381},
  annote =	{Keywords: Calculus of Inductive Constructions, parametricity, impredicativity, Coq, universes}
}

@misc{selsam2020tabledtypeclassresolution,
      title={Tabled Typeclass Resolution}, 
      author={Daniel Selsam and Sebastian Ullrich and Leonardo de Moura},
      year={2020},
      eprint={2001.04301},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2001.04301}, 
}
@article{MILNER1978348,
title = {A theory of type polymorphism in programming},
journal = {Journal of Computer and System Sciences},
volume = {17},
number = {3},
pages = {348-375},
year = {1978},
issn = {0022-0000},
doi = {https://doi.org/10.1016/0022-0000(78)90014-4},
url = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
author = {Robin Milner},
abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.}
}

@article{NADATHUR200235,
title = {The Suspension Notation for Lambda Terms and its Use in Metalanguage Implementations},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {67},
pages = {35-48},
year = {2002},
note = {WoLLIC'2002, 9th Workhop on Logic, Language, Information and Computation},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80539-5},
url = {https://www.sciencedirect.com/science/article/pii/S1571066104805395},
author = {Gopalan Nadathur},
keywords = {logical framework, explicit substitution, suspension notation},
abstract = {Many metalanguages and logical frameworks have emerged in recent years that use the terms of the lambda calculus as data structures. A common set of questions govern the suitability of a representation for lambda terms in the implementation of such systems: α-convertibility must be easily recognizable, sharing in reduction steps, term traversal and term structure must be possible, comparison and unification operations should be efficiently supported and it should be possible to examine terms embedded inside abstractions. Explicit substitution notations for lambda calculi provide a basis for realizing such requirements. We discuss here the issues related to using one such notation—the suspension notation of Nadathur and Wilson—in this capacity. This notation has been used in two significant practical systems: the Standard ML of New Jersey compiler and the Teyjus implementation of λ-Prolog. We expose the theoretical properties of this notation, highlight pragmatic considerations in its use in implementing operations such as reduction and unification and discuss its relationship to other explicit substitution notations.}
}

@article{10.1145/3236788,
author = {Stampoulis, Antonis and Chlipala, Adam},
title = {Prototyping a functional language using higher-order logic programming: a functional pearl on learning the ways of $\lambda$Prolog/Makam},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236788},
doi = {10.1145/3236788},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {93},
numpages = {30},
keywords = {programming language prototyping, metaprogramming, higher-order logic programming}
}

@article{10.1145/3429979,
author = {Tabareau, Nicolas and Tanter, \'{E}ric and Sozeau, Matthieu},
title = {The Marriage of Univalence and Parametricity},
year = {2021},
issue_date = {February 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {68},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/3429979},
doi = {10.1145/3429979},
abstract = {Reasoning modulo equivalences is natural for everyone, including mathematicians. Unfortunately, in proof assistants based on type theory, which are frequently used to mechanize mathematical results and carry out program verification efforts, equality is appallingly syntactic, and as a result, exploiting equivalences is cumbersome at best. Parametricity and univalence are two major concepts that have been explored in the literature to transport programs and proofs across type equivalences, but they fall short of achieving seamless, automatic transport. This work first clarifies the limitations of these two concepts when considered in isolation and then devises a fruitful marriage between both. The resulting concept, called univalent parametricity, is an extension of parametricity strengthened with univalence that fully realizes programming and proving modulo equivalences. Our approach handles both type and term dependency, as well as type-level computation. In addition to the theory of univalent parametricity, we present a lightweight framework implemented in the Coq proof assistant that allows the user to transparently transfer definitions and theorems for a type to an equivalent one, as if they were equal. For instance, this makes it possible to conveniently switch between an easy-to-reason-about representation and a computationally efficient representation as soon as they are proven equivalent. The combination of parametricity and univalence supports transport \`{a} la carte: basic univalent transport, which stems from a type equivalence, can be complemented with additional proofs of equivalences between functions over these types, in order to be able to transport more programs and proofs, as well as to yield more efficient terms. We illustrate the use of univalent parametricity on several examples, including a recent integration of native integers in Coq. This work paves the way to easier-to-use proof assistants by supporting seamless programming and proving modulo equivalences.},
journal = {J. ACM},
month = jan,
articleno = {5},
numpages = {44},
keywords = {Coq, Type equivalence, parametricity, proof assistants, univalence}
}

@phdthesis{enzo,
  title        = {Meta-Programming for Proof Transfer in Dependent Type Theory},
  author       = {Enzo Crance},
  year         = 2023,
  month        = {December},
  address      = {Nantes},
  note         = {Available at \url{https://ecrance.net/files/thesis-Enzo-Crance-en-light.pdf}},
  school       = {University of Nantes},
  type         = {PhD thesis}
}

@phdthesis{mcbride,
  author       = {Conor McBride},
  title        = {Dependently typed functional programs and their proofs},
  school       = {University of Edinburgh, {UK}},
  year         = {2000},
  url          = {https://hdl.handle.net/1842/374},
  timestamp    = {Wed, 04 May 2022 12:59:24 +0200},
  biburl       = {https://dblp.org/rec/phd/ethos/McBride00.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@article{Miller2018MechanizedMR,
  title={Mechanized Metatheory Revisited},
  author={Dale A. Miller},
  journal={Journal of Automated Reasoning},
  year={2018},
  volume={63},
  pages={625 - 665},
  url={https://api.semanticscholar.org/CorpusID:8571809}
}